---
layout: page 
title :  Port Full Scan 
categories : [tools, Nmap, Dscan]
---


## Effective Service Enumeration

In this post we will adress one of the tasks that haunts every pentester or red team operator, **service enumeration**, Its a known issue for every red team operator / pentester, spetially daunting the first time it faces a recon on a **Class A** network address range.


**A tipical service enumeration technics**, comprises: 

- **Host discovery:** Create a list of live hosts (as close to 100%) as possible. 
- **Port Scaning:**  Find the exposed services on the hosts found by the previous step. 
- **Version Scan:** This last step assists the operator in prioritizing what services to test first or to leave behind. 


If you ever did a pentest for a big corporate network you'r probably already hearing the eco of the project's budjet / clock, this is one of the main differences between a threat actor and a pentester, threat actors don't have tight bugjects or limited to a few weeks this fact alone **MAKES ALOT OF DIFFENTECE**  as every setep is taken with a huge amount of information and well contextualized.  

In the end what does this mean?

This means port scanning is not always needed once they are inside the network and when it its they have the time on their side the slower the actions less noise they will make, this is key not only to maintain the access, but also to avoid raising flags, one of such technics takes advantage of **lateral movents** as for every new compromise amoung the information collected is services and resources envolved in does services a **black box analisys** becomes a **white box**. 

Alot has been done and writen about his topic, **nmap** is the most known but thier are others **masscan** **zmap** and others, in this post i wll talk about **nmap** i  find it more relyable than others i tryed the **asyncronos** scan is a hot topic and fiercely debated, the issue with **asyncronos** and networking is latenecy it short slow reponsces leads to **false negatives** meaning closed ports that are actualy open but behind something that slows down the reponce. 


### Discovery 

Active discovery is usally the second step of theirs work to be done before this namely: 

- Who is the **dhcp**.
- Where is the host located in the network.
- What is the **ipaddress** of the host. 

Some of this information is avaliable in the os other can be collected by listening to the network with a tool like netdiscovery, after this step **active discovery** is contextualzed, this means the operator should be able to determine the potential number of neighbors. 

A critical information for this step is the address range the latency of the network / bandwith and existence of filters of any kind, personaly i tend to opt betwen 3 methods of discovery. 


#### DNS BASED

This means i found a way to collect significant amount of internal names that can be used to establish range of addresses considering the **class** of address ranges for **Class A** or **class B** one of the most used methods is to split the ranges in subtnets **/24** this will create a constant stream of information to be preocessed. 


#### Ping sweeps

This can be done with many tools like everthing in this field, nmap is able to do this and uses it to create internal statistics to aid its planing and prediction algorithms, in modern networks this might be a source of **huge pain icmp** block or slowdowns will affect the accuracy and the amount of time spent on each target. 

#### Port acknowledge 

For the lack of a better term it means electing a range of ports to be used as beacons to establish if the host is live or not, confused ? its actualy more simple that it seems, after a some time you will realyze some ports tend to **be as open** in spesific systems  eg: Windows 3398,445, 135 Linux: 22. to name a few. The advantages of this technic is it doesn't rely on icmp and nmap is still able to make its statistics to plan the execution resulting in shorter times. 


### Port Scanning

I read this once, "port scanning is the equivalent o geting into a buildingf and knock on every door, to see who lives their", simple but true this means the objective goal would be to reach all **65535 ports on every host** many say a comprensive pentest will allways include a full TCP/UDP scan,
one of the rationals behind this is to provide information need from security prespective, but not critical enouph for the local teams to execute regularly, although this has changed and some companies actualy scan their networks regularly. 

The question is how to make this effective and extract rellyable and accurate information berfore all your hardware becomes obsolete. :)
Over the years i tryed many things, some o came up by my self others i borrowed from others, the one i find most effective is split port  and ip  address in ranges,  "usually called staged scan", making them more managable.
As the information arrives one can aggregate it and prioritize the services that will be looked at first. 

An example of it would be:

```
80,443,8080
25,135,137,139,445,1433,3306,5432
23,21,22,110,111,2049,3389
0-20,24,26-79,81-109,112-134,136,138,140-442,444,446-1432,1434-2048,2050-3305, \
3307-3388,3390-5431,5433-8079,8081-29999
30000-65535
```    

As allways theirs also a downside, this also means you will need to keep an eye on the scanner and avoid it beeing stoped between stages, this was were i started craft some code to automate, **[Dscan](https://github.com/0x4E0x650x6F/dscan "Distribuited Scan")** was born from the need to maintain acitive relyable stream of information flowing even if the pentester is not their, the smaller the tast less resources it needs (in therory at least),  hypothetically one could create something that after setup would work on the scan stage after stage and keep the results, and resume if it something goes wrong.
This also opens up the possiblity of leaving something behind after hours, and spreating the proboes over a longer time frame.

The way i usually did this was:

- **split the network addresses**  in calss C address CIDR
- **split the port ranges** into managble ranges is usefull to consider the network bandwtith, number of team members, and other limitations that might come up.
-**filter** the services indentiflied easily, and calssify them based on a priority.
-**version scan** some servirces would require a version scan or vulnerability checks, this are usualy services where the protocol is not easly identified or when knowing a service version could aid the operator in finding potential vulnerabilities to be exploited.


The firs two steps are easlly automated and would result ins something like. 

```
nmap -n -sn -PE -PP -PS 21,22,23,25,80,113,31339 -PA 80,113,443,10042 <ip-range> -oA <ip-range>
nmap -n -sS -PE -PP -PS 21,22,23,25,80,113,31339 -PA 80,113,443,10042 -p25,135,137,139,445,1433,3306,5432 <ip-range> -oA <ip-range>
``` 

After a while as most pentesters, i started to create serveral scripts to mange this and free my self from this task in a more automated way and last year i decided to make a tool to not only do this but allow one or more systems to colaborate while maintaing a close eye on the progress, and **Dscan** was born.

<iframe width="560" height="315" src="https://www.youtube.com/embed/3wY6gpH_8rE" frameborder="0" allowfullscreen></iframe>

### Dscan 

Dscan is a small distributed application, with two components **server** and **agent** they are linked to each other by an tcp connection with ssl tunnel to protect the information from tampering we all know the amount of shenanigans auditors find in the client's networks.

A configuration such as the one bellow dettermins the tasks and the targers to be scanned, as well as the place where the reports will be saved. 

```
[base]
reports = reports

[server]
stats = run
targets = ${stats}/targets.work
live-targets = ${stats}/live-targets.work
trace = ${stats}/current.trace

[nmap-ports]
discovery-ports = -PE -PP -PS 21,22,23,25,80,113,31339 -PA 80,113,443,10042
stage1-ports = 80,443,8080
stage2-ports = 25,135,137,139,445,1433,3306,5432
stage3-ports = 23,21,22,110,111,2049,3389
stage4-ports = 0-20,24,26-79,81-109,112-134,136,138,140-442,444,446-1432,1434-2048,2050-3305,3307-3388,3390-5431,5433-8079,8081-29999
stage5-ports = 30000-65535

[nmap-scan]
discovery = -n -sn ${nmap-ports:discovery-ports}
scan-stage1 = -sS -n ${nmap-ports:discovery-ports} -p ${nmap-ports:stage1-ports}
scan-stage2 = -sS -n ${nmap-ports:discovery-ports} -p ${nmap-ports:stage2-ports}
scan-stage3 = -sS -n ${nmap-ports:discovery-ports} -p ${nmap-ports:stage3-ports}
scan-stage4 = -sS -n ${nmap-ports:discovery-ports} -p ${nmap-ports:stage4-ports}
scan-stage5 = -sS -n ${nmap-ports:discovery-ports} -p ${nmap-ports:stage5-ports}

[certs]
sslcert = certfile.crt
sslkey = keyfile.key
ciphers = ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK
cert-hostname = dscan
```

**Q:** Do i need to write all that configuration?
**R:** No, the tool generates a base line, that can be ajusted don't panic. :D

The application allows one to establish a continum service enumeration workflow, that can run beyond office hours, without this reprensenting a risk for the auditor system, a small computer like raspberry pi or other like it can esure the orchestration and scanning outside office hours and reenforced by the auditors in office hours by the auditors computers. 


The process works as follows:

- A certificate and private key is configurated in the server side. 
- Scan details are preparered. 
- Target list is compiled into a text file.
- The server is started with the config file and target's directory.
- The server takes the target's list targets are parsed and optimized generates a .work file, and a .tracefile 
- Certificate is shared with the agent's. 
- Agents connect to the server authenticate, and receives a target starts scanning.

Like all things in life this also **has rules**, the server config file needs to include a discovery stage, this stage is **key** all other stages depend on this to know which targets are live, all reports sent by the agents from this stage are opend processed and the resulting ips are grouped in **cidr** or block range format say **1-10**. 

- Their are no limitations on the number of stages (except for the existence of the discovery).
- Both agent and server keeps a copy of the scan report.
- When an agent is disconnected the target goes to a unfinished pool, distributed next time a new target is requested. 
- In case of a catastrofic failure in the server, the .trace file holds a serialized state of the scan process, enabling it to resume from its previous state,  **including** unfinished or failed scans. 

In sort my solution for a reliable enumeration process.

* Target optmimization.
* Distribribuiton 

This also allows efordless colaboration between auditors. 

You can find the code for this project at  [Dscan](http://github.com/0x4E0x650x6F/dscan "Dscan")
